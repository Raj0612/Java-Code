package com.datastructures.trees.binarytrees;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

//Given the root of a binary tree, return the length of the diameter of the tree.
//The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
//The length of a path between two nodes is represented by the number of edges between them.
public class DiameterOfBinaryTree {
    static private int maxDiameter;
    public static void main(String[] args) {
       // input1();
      //  input2();
      //  input3();
        input4();
    }

    static void input1(){
        TreeNode root = BinaryTree.constructTree7();
        /*     1
              / \
             2   3
           / \
          4   5
         */
        System.out.println("input1 diameterOfBinaryTree " + diameterOfBinaryTree(root));
      //  System.out.println("input1 leftHeight " + leftHeight(root));
        System.out.println("input1 diameterOfBinaryTree1 " + diameterOfBinaryTree1(root));
       System.out.println("diameterOfBinaryTreeByNonRecursionStack " + diameterOfBinaryTreeByNonRecursion(root));
        System.out.println("input1 maxDepthNonRecursive " + maxDepthNonRecursive(root));
    }

    static void input2(){
        TreeNode root = new TreeNode(4);
        root.left = new TreeNode(2);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(1);
        root.left.left.left = new TreeNode(5);
         /*    4
              /
             2
           / \
          3   1
         /
        5
         */

       // System.out.println("DiameterByQueue " + diameterOfBinaryTreeByNonRecursion(root));//Error
        System.out.println("input2 leftHeight " + leftHeight(root));
        System.out.println("input2 diameterOfBinaryTree " + diameterOfBinaryTree(root));
        System.out.println("input2 diameterOfBinaryTree1 " + diameterOfBinaryTree1(root));
        System.out.println("input2 maxDepthNonRecursive " + maxDepthNonRecursive(root));
        System.out.println("input2 diameterOfBinaryTreeByNonRecursionStack " + diameterOfBinaryTreeByNonRecursion(root));
    }

    static void input3(){
        TreeNode root = BinaryTree.constructTree10();
          /*   1
              / \
             2   3
           / \
          4   5
             /
            6
         */
        System.out.println("input3 leftHeight " + leftHeight(root));
        System.out.println("input3 diameterOfBinaryTree " + diameterOfBinaryTree(root));
        System.out.println("input3 diameterOfBinaryTree1 " + diameterOfBinaryTree1(root));
        System.out.println("input3 maxDepthNonRecursive " + maxDepthNonRecursive(root));
        System.out.println("input3 diameterOfBinaryTreeByNonRecursionStack " + diameterOfBinaryTreeByNonRecursion(root));
    }

    static void input4(){
        TreeNode root = new TreeNode(4);
        System.out.println("input3 diameterOfBinaryTree " + diameterOfBinaryTree(root));
        System.out.println("input3 diameterOfBinaryTree1 " + diameterOfBinaryTree1(root));
    }

    public static int diameterOfBinaryTree(TreeNode root) {
        int leftHeight =  height1(root.left);
        int rightHeight =  height1(root.right);
        return leftHeight + rightHeight;
    }
    private static int height1(TreeNode node) {
        if (node == null) {
            return 0;
        }

        int leftHeight = height1(node.left);
        int rightHeight = height1(node.right);

        return 1 + Math.max(leftHeight, rightHeight);
    }

    public static int diameterOfBinaryTree1(TreeNode root) {
        maxDiameter = 0;
        height(root);
        return maxDiameter;
    }

    private static int height(TreeNode node) {
        if (node == null) {
            return 0;
        }

        int leftHeight = height(node.left);
        int rightHeight = height(node.right);

        maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);
        return 1 + Math.max(leftHeight, rightHeight);
    }

    public static int leftHeight(TreeNode root) {
        int leftHeight = height1(root.left);
        return leftHeight;
    }

    //Wrong
    static int maxDepthNonRecursive(TreeNode root) {
        if (root == null) return 0;

        int diameter = 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            diameter++;
            while (size-- > 0) {
                TreeNode node = queue.poll();
                if (node.left != null)
                    queue.offer(node.left);
                if (node.right != null)
                    queue.offer(node.right);
            }
        }
        return diameter;
    }
    public static int diameterOfBinaryTreeByNonRecursion(TreeNode root) {
        int leftHeight = 0;
        int rightHeight = 0;
        if(root.left!=null)
         leftHeight = maxDepthNonRecursiveStack(root, true);
        if(root.right!=null)
         rightHeight = maxDepthNonRecursiveStack(root, false);

        return (leftHeight+ rightHeight);
    }

    //Wrong
    static int maxDepthNonRecursiveStack(TreeNode root, boolean left) {
        Stack<TreeNode> stack = new Stack<>();
        int depth = 0;
        if((left && root.left==null) || (!left && root.right == null)){
            return depth;
        }
        stack.add(root);

        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (left && node.left != null)
                stack.add(node.left);
            if (left && node.left == null && node.right != null)
                stack.add(node.right);
            if (!left && node.right != null)
                stack.add(node.right);
            if (!left && node.right == null && node.left != null)
                stack.add(node.left);
            depth++;
        }
        return depth-1;
    }
}
