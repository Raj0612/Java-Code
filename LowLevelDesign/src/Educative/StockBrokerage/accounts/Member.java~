package Educative.StockBrokerage.accounts;

import Educative.StockBrokerage.enums.*;
import Educative.StockBrokerage.interfaces.StockObserver;
import Educative.StockBrokerage.orders.*;
import Educative.StockBrokerage.stockexchange.StockExchange;
import Educative.StockBrokerage.stocks.*;

import java.time.LocalDate;
import java.util.*;

public class Member extends Account implements StockObserver {
    private double availableFundsForTrading;
    private LocalDate dateOfMembership;
    private Map<String, StockPosition> stockPositions;
    private Map<Integer, Order> activeOrders;
    private List<Watchlist> watchlists;

    public Member(String id, String password, String name, Address address, String email, String phone, double initialFunds) {
        super(id, password, name, AccountStatus.ACTIVE, address, email, phone);
        this.availableFundsForTrading = initialFunds;
        this.dateOfMembership = LocalDate.now();
        this.stockPositions = new HashMap<>();
        this.activeOrders = new HashMap<>();
        this.watchlists = new ArrayList<>();
    }

    public ErrorCode placeSellLimitOrder(String stockId, double quantity, double limitPrice, TimeEnforcementType enforcementType) {
        Stock stock = StockInventory.getInstance().searchSymbol(stockId);
        if (stock == null) return ErrorCode.STOCK_NOT_FOUND;
        StockPosition pos = stockPositions.get(stockId);
        if (pos == null || pos.getQuantity() < quantity) return ErrorCode.INVALID_ORDER;
        LimitOrder order = new LimitOrder(this, stock, quantity, limitPrice, enforcementType, false);
        activeOrders.put(order.getOrderNumber().hashCode(), order);
        StockExchange.getInstance().registerObserver(stockId, this);
        StockExchange.getInstance().placeOrder(order);
        return ErrorCode.SUCCESS;
    }

    public ErrorCode placeBuyLimitOrder(String stockId, double quantity, double limitPrice, TimeEnforcementType enforcementType) {
        Stock stock = StockInventory.getInstance().searchSymbol(stockId);
        if (stock == null) return ErrorCode.STOCK_NOT_FOUND;
        double cost = quantity * limitPrice;
        if (availableFundsForTrading < cost) return ErrorCode.INSUFFICIENT_FUNDS;
        LimitOrder order = new LimitOrder(this, stock, quantity, limitPrice, enforcementType, true);
        activeOrders.put(order.getOrderNumber().hashCode(), order);
        StockExchange.getInstance().registerObserver(stockId, this);
        StockExchange.getInstance().placeOrder(order);
        return ErrorCode.SUCCESS;
    }

    public void callbackStockExchange(int orderId, List<OrderPart> orderParts, OrderStatus status) {
        // Update order status and positions/funds accordingly
        Order order = activeOrders.get(orderId);
        if (order != null) {
            order.setStatus(status);
            // Update positions and funds based on orderParts
            // Omitted for brevity
        }
    }

    @Override
    public void update(Stock stock) {
        // Check all active orders for this stock and trigger if price matches
        for (Order order : activeOrders.values()) {
            if (order.getStock().getSymbol().equals(stock.getSymbol()) && order.getStatus() == OrderStatus.OPEN) {
                if (order.isBuyOrder() && stock.getPrice() <= order.getLimitPrice()) {
                    order.execute();
                } else if (!order.isBuyOrder() && stock.getPrice() >= order.getLimitPrice()) {
                    order.execute();
                }
            }
        }
    }

    @Override
    public boolean resetPassword() {
        // Reset logic
        return true;
    }
}
